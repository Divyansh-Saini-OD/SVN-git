SET SHOW         OFF
SET VERIFY       OFF
SET ECHO         OFF
SET TAB          OFF
SET FEEDBACK     ON

-- +=======================================================================+
-- |               Office Depot - Credit Card Purge                         |
-- |      Oracle NAIO/Office Depot/Consulting Organization                 |
-- +=======================================================================+
-- | Name        : XX_CC_PURGE_IBY_AR_DATA.sql                                |
-- | Description : Script to purge the Credit Card data for few CreditCardTypes |
-- |                                                                       |
-- |Change History:                                                        |
-- |---------------                                                        |
-- |                                                                       |
-- |Version  Date        Author             Remarks                        |
-- |-------  ----------- -----------------  -------------------------------|
-- | DraftA  25-Feb-2015  Rajeev            Created by Rajeev              |
-- | 1.0     25-Feb-2015  Madhu Bolli       Edited to create normal script |
-- +=======================================================================+

/***************************************************************************************************
	Create a procedure to delete child records and then master records
	using the ids generated by diving the master table into chunks.
	This procedure will be called by the script to be run in parallel
****************************************************************************************************/


CREATE OR REPLACE PROCEDURE XXOD_DELETE_IBY_AR_DATA (p_start_id IN NUMBER, p_end_id IN NUMBER) AS

BEGIN

   delete iby_pmt_instr_uses_all piua
    where exists (select /*+ USE_HASH(CC XAIO) */ 1 
                    from iby_creditcard CC,
						 xxfin.xx_ar_intstore_r12_temp XAIO
                   where cc.instrid        = piua.instrument_id
				     and cc.card_owner_id  = xaio.party_id
                     and cc.instrid between p_start_id and p_end_id
                 )
	 and piua.instrument_type = 'CREDITCARD'
	 and piua.instrument_id between p_start_id and p_end_id;


    delete iby_security_segments iss
     where exists (select /*+ USE_HASH(CC XAIO) */ 1  
                     from iby_creditcard CC,
                          xxfin.xx_ar_intstore_r12_temp XAIO 					 
                    where cc.cc_num_sec_segment_id = iss.sec_segment_id
					  and CC.card_owner_id         = XAIO.party_id
                      and cc.instrid between p_start_id and p_end_id                    
                  );

   delete iby_creditcard CC
    where exists (select /*+ USE_HASH(CC XAIO) */ 1 
				    from xxfin.xx_ar_intstore_r12_temp XAIO
                   where  CC.card_owner_id  = XAIO.party_id)
      and  CC.instrid between p_start_id and p_end_id;
					 
commit;

end  XXOD_DELETE_IBY_AR_DATA;

/
  
/***************************************************************************************************
	Create task, divide master table into chunks, then run the task
****************************************************************************************************/

DECLARE

  l_task     VARCHAR2(30)     := 'DELETE_IBY_AR_CC_DATA';
  l_sql_stmt VARCHAR2(32767)  := 'BEGIN  XXOD_DELETE_IBY_AR_DATA(:start_id, :end_id); END;';
  l_try      NUMBER;
  l_status   NUMBER;

BEGIN

	-- create a task
	DBMS_PARALLEL_EXECUTE.create_task (task_name => l_task);
	-- point to key column and set batch size
	DBMS_PARALLEL_EXECUTE.create_chunks_by_number_col
		(task_name    => l_task,
		table_owner  => 'IBY',
		table_name   => 'IBY_CREDITCARD',
		table_column => 'INSTRID',
		chunk_size   => 100000);

	DBMS_PARALLEL_EXECUTE.run_task(task_name    => l_task,
                                 sql_stmt       => l_sql_stmt,
                                 language_flag  => DBMS_SQL.NATIVE,
                                 parallel_level => 10);

	l_status := DBMS_PARALLEL_EXECUTE.task_status(l_task);

	dbms_output.put_line('l_status = '||l_status);

	
  -- If there is error, Try resuming the task for 2 more times.
  l_try := 0;
  l_status := DBMS_PARALLEL_EXECUTE.task_status(l_task);
  WHILE(l_try < 2 and l_status != DBMS_PARALLEL_EXECUTE.FINISHED)
  Loop
    l_try := l_try + 1;
    DBMS_PARALLEL_EXECUTE.resume_task(l_task);
    l_status := DBMS_PARALLEL_EXECUTE.task_status(l_task);
  END LOOP;
  
/*
-- Monitor status
 SELECT chunk_id, status, start_id, end_id
FROM   user_parallel_execute_chunks
WHERE  task_name = 'DELETE_IBY_CC_DATA'
ORDER BY chunk_id;

--delete task

DBMS_PARALLEL_EXECUTE.DROP_TASK (l_task);

dbms_output.put_line('Task '||l_task||' dropped');

--To view all running jobs --> USER_SCHEDULER_RUNNING_JOBS
--To view job statuses --> USER_SCHEDULER_JOB_RUN_DETAILS
--To view log details --> USER_SCHEDULER_JOB_LOG

*/

end;
/
